---
title: "CGE in R - Practical sessions"
subtitle:  |
  | [Universidad Iberoamericana Ciudad de México]{style="color: grey;font-size: 0.95em;letter-spacing: 1px;line-height: 0.25;"}
  | [Taller: Modelos de Equilibrio General Neokeynesianos Dinámicos en R]{style="color: blue;font-size: 0.95em;letter-spacing: 1px;line-height: 0.25;"}
date: "`r format(Sys.Date(), '%d %B %y')`"
author: 
  - Frédéric Reynès 
  - Anissa Saumtally
format: 
  pres-revealjs:
    width: 1200
    height: 750
    
toc: false
eval: false
---



# Introduction 

## Foreword: codename *Ermeeth project*

<br>

- The CGE platform presented today is the a suite of scripts and packages initially developed to run the ThreeME model in R
- This platform is versatile as even the simplest models can be run
- Multiple system solvers from external applications can be mobilised to solve the model, 
  + These session will only use a solver written in R that works well on small scale models
- These practical sessions aim at giving you a preview of a workflow of model simulation and result analysis on simple models

## A standard workflow on the Ermeeth project platform

<br>

- create/edit your model 

- create/edit your baseline and shock scenarios

- Prepare your config files

- Prepare your main file

- Prepare a simple .qmd output (or use a template!)

- Test it, fix errors (there is always something..)

- Run simulations again.

- Develope more advance analysis to understand behaviours


# Practical Session 1 

## Session objectives

<br>

- Full software installation

- Downloading the repository

- Discovering the CGE in R simulation platform 

  + Navigating the repository structure
  + Main files presentation
  + Simulation output information
  + Quarto introduction 
  
- Making sure everything runs!

## Download links

<br>

- Please go to (https://ThreeME-org.github.io/CGE_inR_iberomex/install)[]
  + Download and install the 3/4 softwares linked
  + Download the repository  off GitHub (no account necessary)
  + Package installation 
  
- What are you installing ?
  + R is the basic R langage software
  + RStudio provides a user-friendly IDE to run R]
  + Rtools for Windows adds advanced functionalities to R[^1]. 
  + Quarto is a markdown-based software used to combine code elements and text in order to produce reports that depend on code output.
  
  
  [^1]: Rtools version must match the R version installed
  
- Run the `main_test.R` script to make sure it all works.


## Quarto introduction


For result analysis, we use [Quarto](https://quarto.org/docs/guide/). It's a markdownbased format that allows to easily integrate code and text with additional syntax for more complex content, like code blocks, citations, and equations, which makes it accessible for both technical and non-technical users.

  - **Open-source Publishing Tool**: Quarto is an open-source, next-generation publishing tool that allows users to create and publish documents, reports, presentations, websites, blogs, and more.
  
  - **Supports Multiple Formats**: It seamlessly integrates with a variety of output formats, including HTML, PDF (typst, $\LaTeX$), Word, and ePub, making it versatile for creating different types of content.
  
  - **Multiple programming languages **: While it has strong support for R and Python, Quarto also works well with other programming languages.
  
  - **Data Visualization and Analysis**: It enables the integration of live code, allowing users to generate and update visualizations and analyses directly in the document, which is ideal for reproducible research.
  
- **Customizable and Extensible**: With options for custom styling, templates, and themes, 

## LIVE DEMO {.center}

**Basic steps to creating a quarto file**

## Basic folder strucure presentation  {.scrollable}

- The `Main_xx.R` file: this is the main simulation file

- The `configuration` folder contains:
  + `config_input_xx.R`: file used to prepare the simulation parameters
  + `config_output_xx.R`: file used to specify the quarto result templates to be used
  + `scenarii_calib` folder: folder contains the script to prepare the simulation scenarios (baseline and shocks)
  
- The `data` folder with the `output` subfolder: where are stored the simulation results as `rds` files.

- The `results` folder contains the pre-programmed quarto templates. Can be used to store your own results.

- The `src` folder contains a few system files and scripts, many of which are not directly of interest to users, with the exception of:
  + `model`: contains the model files (`.mdl`), that is the equations and data calibration for models. Users may modify or add `mdl` files to suit the specifics of their simulations.
  + `functions_src`: contains user-made, not yet packaged functions. Users may create their own functions and store them in this folder to call upon them automatically.
  + `setup.R`: loads packages and user-made functions 

## LIVE DEMO {.center}

**Overview of the project folder structure**

## Complete Exercise 1 

Installation and tests {#sec-1_1}

-   Follow the installation instructions specified in *Get Started*

-   Run the file `main_test.R` to check if everything is working properly

-   Familiriaze yourself with the folder structure by locating the following files:

    -   `Main.R`
    -   `config_input_MODEL.R` and `config_output.R`
    -   `1_calib_baseline.R`
    -   `01-1-eq_one_equation_model.mdl`

## the `Main.R` file

`Main.R` script is built on four steps.

### Step 0: Setup

-   resets the `R` environment
-   loads the necessary libraries and custom functions
-   reads the simulation configurations (*input* and *output*) into the `config` list.

```{r}
#| eval: false
#| echo: true

## 0. Setup
rm(list = ls())
source(file.path("src","setup.R"))


  config <- readconfig(input_config_file = file.path("configuration", "config_input_XXX.R") ,
                      output_config_file = file.path("configuration", "config_output_XXX.R")
                     )
```

------------------------------------------------------------------------

### Step 1: Calibration bubble (**OPTIONAL**)

-   **optional**: by default deactivated
-   Facilitates the calibration of scenarios

```{r}
#| eval: false
#| echo: true

## 1. OPTIONAL Prepare the baseline and/or shock calibration files by uncommenting the lines

# ## >>>>>>> uncomment start
# calibration_bubble <- calibration_environment(baseline_calibration = FALSE)
# list2env(calibration_bubble, envir = globalenv())
# ### You may now open the relevant scenario config file to edit and test it
# rm(list = names(calibration_bubble))
# ## <<<<<<< uncomment end

```

------------------------------------------------------------------------

### Step 2: Run simulations

-   runs the simulations based on the configuration specified in Step 0

```{r}
#| eval: false
#| echo: true


## 2. Running simulations


data_full <- run_simulations(configuration = config)
```

-   function running all the necessary steps to simulate the model
    -   reading and interpreting `.mdl` blocks
    -   launching the solver.
    -   returns a database containing simulation results of all the scenarii specified in the configuration input

------------------------------------------------------------------------

### Step 3.A: Produce selected result templates (**OPTIONAL**)

-   **Optional**: will run predefined quarto templates to explore simulation results

```{r}
#| eval: false
#| echo: true
#| 
### 3.A Using templates 

produce_quartos(Show = TRUE)
cleanup_output(render_dir = ".") # to clean older html renders, keeping the last versions only

```

-   Templates are selected in the `config_output` file
-   Activating the `Show` argument by selecting `TRUE` will display automatically the results in your web browser

------------------------------------------------------------------------

### Step 3.B: Render your own quarto document (**OPTIONAL**)

-   **Optional**: to render a user-made quarto file to view and analyze your results.

```{r}
#| eval: false
#| echo: true

### 3.B Your own quarto file
output_file = paste0("Results_",config$input$project_name,".html")

quarto::quarto_render(input = file.path("my_quarto.qmd"),
                      output_file = output_file,
                      output_format = "html",
                      execute_params = list(scenario = config$input$scenario)
                      )

browseURL(file.path("results/quarto_render/", output_file) )

```


In order to use it :

-   create, edit and save your own `.qmd` file (ie `my_quarto.qmd`). **Save it at the root of the folder**
-   execute the line to render the file.
-   `browseURL` line will open the rendered output in your web browser


## Complete Exercise 2 (part 1) 

-   Create a copy of the `Main.R` file (call it `Main_one_eq.R` for example) in the root folder

-   On your new `Main` file, call the the config files : `config_input_one_eq.R`, and `config_output_one_eq.R`.

-   Run the simulation and generate the results from templates.

    -   From the results, what do you think happens in this shock scenario?


## The output database : `data_full`


The structure of output simulations is standardised as a simple `data.frame` object with standardised column names in order to facilitate the usage of functions and templates on the outputs. 

```{r}
#| echo: false
#| eval: true
#| include: false

library(tidyverse)


data_full <- readRDS("sampledata/standard_shocks_lite.rds") 

```


Below is a random sample of the `data_full` database created from the `run_simulations()` command.

```{r}
#| eval: true
#| title: data_full
#| filename: "bridge_c17_s17.R"
#| code-summary: "data_full (random sample)"
#| code-fold: true

slice_sample(.data = data_full,n = 10)

```

By default the table is sorted by variable, year and scenario in this order.


```{r}
#| eval: true
#| title: data_full
#| filename: "bridge_c17_s17.R"
#| code-summary: "data_full (default ordered sample)"
#| code-fold: true



head(data_full)
```

## Data columns 

`data_full` is made up of 8 columns:

::: panel-tabset


### `variable`

type `[string]`

This column contains the name of the variables. The variables names are always alphanumerical characters (including underscores) in UPPERCASE.

### `year`

type `[integer]`

This column contains the year of the observation. It serves as the time series identifier, which does not necessarily have to be a calendar year. It could be identified by sequence of integer in any range (ie 1 to 10). The name `year` is a mainly a legacy feature.

### `sector`

type `[string]`

This is a ThreeME specific item that can be used by any model using a similar list system to identify sectors. This is only a label variable. Its value is by default `NA` unless the `variable` is considered to be a sector specific variable, in which case the value reported will be either the sector code or the sector name if a `codenames` file has been properly configured.

### `commodity`

type `[string]`

This is a ThreeME specific item that can be used by any model using a similar list system to identify commodities. This is only a label variable. Its value is by default `NA` unless the `variable` is considered to be a commodity specific variable, in which case the value reported will be either the commodity code or the commodity name if a `codenames` file has been properly configured.

### `scenario`

type `[string]`

This is the (short) name of the scenario, as specified in the `scenario` argument of the `config_input` file. 

### `values_ref`

type `[numeric]`

This column contains the chosen reference scenario value. The reference scenario is the one specified in the `scenario_baseline` argument in the `config_input`.[^2]

[^2]: On an unmodified `data_full` from the simulations, for the *baseline* scenario the values in `values` and `values_ref` are equal.



### `values`

type `[numeric]`

This column contains simulated value for the observation. This is where the main outputs are found.


### `index_scen`

type `[dummy]`

This variable takes the value **1** if the scenario is baseline or **0** otherwise. It's main purpose is to quickly filter out the *baseline* scenario from the database. The information given for this variable is essentially redundant with the information from the `scenario` column.

:::


## Understanding the observations (rows of  `data_full`)

<br>

`data_full` is organised as a long-form `data.frame`, that is all the model variables are listed in a single columns, as well as all the observations values.


**The minimum observation identifier variables are : the `variable`, the `year` and the `scenario`**

- to extract data use `dplyr::filter`

```{r}
#| echo: true
#| code-fold: true
#| 
data_full |> filter(variable %in% "CH") |>  filter(scenario %in% "ct1")


```

- to create new variable, transform the data in *wide format*, make your transformations, and turn it back into *long format* [Advanced, for next session]
 


## `config_input`: to specify the parameters of the simulation {.center}

- To configure the simulation, use the `config_input_MODEL.R` found in the `configuration` folder.

 `config_input_MODEL.R` is meant to be a template, so it is advised to make a copy for your own usage.
 

## `config_input`: Structure of the file - Basic parameters {.scrollable}



The first section of the `config_input` file contains the basic parameters that need to be adapted for each simulation :

  - `iso3`: the country code, useful if using a ThreeME model, make sure ta version of ThreeME exists for the country in question          
  - `classification`: if using a ThreeME model number of commodities and sectors with the following format `cx_sy` where `x` is the number of commodities and `x` the number of sectors. Check that the desired classification exists in the mdl files
  - `model_folder`: the folder where to find the `mdl` files (either `training` or `threeme` usually)
  - `project_name`: name to give your project, must be alphanumeric and underscore characters only. No accents. lowercase only
  - `scenario_baseline` : Name of the baseline scenario. By default it is "baseline-steady". It may be modified if the baseline needs to integrate some user-specified trajectories of exogenous variables.  All scenarii files are located in configuration/scenarii_calib
  - `scenario`: Name of scenario(s) to run. Make sure a file 2_calib_shock_NAMEOFSCENARIO exists in the `configuration/scenarii_calib` folders. Scenario naes must be alphanumeric and underscores in lowercase only. The `scenario` parameter can be a named vector in order to give more information about the scenario that can be reused in results outputs, e.g.: 
  
```{r}
  scenario = c("ct1", "expg1") |> 
  set_names(c("Increase of carbon tax  ","Increase in government spending of 1% of GDP"))
```
  

  - `baseyear`: Input the base year used for the calibration data 
  - `lastyear`: Last year of the simulations
  - `shockyear`: year of the shock. This is an optional parameter that can be called upon when calibrating shocks
  - `max_lags`: maximum lags used in the model, to know how far back the database must go in order for the solver to evaluate all model equations.
  - `firstyear`: By default this is `baseyear - max_lags` (rarely needs to be modified)
  - `automated_shocks`: Set to TRUE if you want to use automated shocks, that will read one unique shock scenario file that can run different calibrations according to the scenario name (*needs further documentation*)
 - `variables_to_keep`: Vector of variables to keep in the output. Input an empty vector (`c()`) in order to keep all variables.

## `config_input`: Structure of the file - Model file lists 

The second sections contains `mdl` file lists. In three parts, there are:

  - `list_files` : basic files (maily for ThreeME, does not need to be modified)
  - `calib_files`: `mdl` files that contain data calibration equations
  - `model_files`: `mdl` files that contain the models equations. 
  
  

::: {.panel-tabset}

#### Training model 

```{r}
#| echo: true
#| code-overflow: scroll
#| 
lists_files <- c(
  "lists.mdl" 
)

## Calibration files
calib_files <- c(lists_files,
                 "03.1-calib.mdl",     # Close economy
                 "03.2-calib.mdl",     # Open economy
                 
                 "ENDOFLINE.mdl"       # ALL VERSIONS: empty file
                 
)

# Model files 
model_files = c(lists_files,
                
                "03.1-eq.mdl",         # Close economy 
                "03.2-eq.mdl",         # Close economy
                
                "ENDOFLINE.mdl"        # ALL VERSIONS: empty file
                
)
```



#### ThreeME model

```{r}
#| echo: true
#| code-overflow: scroll
#| 

## Lists files (warning: if more than one, place "lists.mdl" last)
lists_files = c(
    str_c("R_lists_", iso3,"_",classification, ".mdl"),             # ALL VERSIONS
    "lists.mdl"                                                     # ALL VERSIONS
  )

## Calibration files (used to initialize variables)
calib_files = c(lists_files,
  str_c("data/R_Calibration_", iso3,"_",classification,"_",baseyear, ".mdl"),   # ALL VERSIONS
  "data/parameters.mdl",                     # ALL VERSIONS
     
  ## Calibration of elasticity of substitutions (Producer)
  "data/elasticities.mdl",                   # ALL VERSIONS
  "data/Exception_NestedCES_data.mdl",     # NESTED CES (PRODUCER) VERSION
  "data/round0.mdl",                         # ALL VERSIONS
  "data/Prices_data.mdl",                    # ALL VERSIONS
  "data/SU_data.mdl",                        # ALL VERSIONS
  "data/Special_data.mdl",                   # ALL VERSIONS
  "data/Other_data.mdl",                     # ALL VERSIONS
  "data/Exception_taxes_prices_data.mdl",    # ALL VERSIONS (when commodity tax rate per user)
  
  ## Optional Consumer blocks
  # "data/Exception_ConsumerNested_data.mdl",  # NESTED CES (CONSUMER) VERSION

  "data/Exception_Other_data.mdl",           # ALL VERSIONS
  # "data/Exception_energybalance_simple.mdl",  # ALL VERSIONS: Only net energy production (Y_TOE). Gross primary energy 
  
  "ENDOFLINE.mdl"                          # ALL VERSIONS
)

# Model files 
model_files = c(lists_files,
  "SU.mdl",                     # ALL VERSIONS 
  "Prices.mdl",                 # ALL VERSIONS
  "Producer.mdl",               # ALL VERSIONS
  "Consumer.mdl",               # ALL VERSIONS
  "Government.mdl",             # ALL VERSIONS
  "Trade_inter.mdl",            # ALL VERSIONS
  "Demography.mdl",             # ALL VERSIONS
  "Adjustments.mdl",            # ALL VERSIONS
  "Verif.mdl",                  # ALL VERSIONS
  "ghg_emissions.mdl",          # ALL VERSIONS
  
  # Option energy balance blocks
  "energybalance.mdl",          # ALL VERSIONS

  ## Exception files ALWAYS at the end because of the @overs
  # "Exception_taxes_prices.mdl",           # ALL VERSIONS
  "Exception_taxes_prices_new.mdl",           # New version where taxes are divided by different users
  # "Exception_NestedCES.mdl",            # NESTED CES (PRODUCER) VERSION
  # "Exception_ConsumerNested.mdl",       # NESTED CES (CONSUMER) VERSION

  "Exception_Other.mdl",                   # ALL VERSIONS
  
  
  "ENDOFLINE.mdl"                          # ALL VERSIONS
)

```

:::

## `config_output`: to specify output templates  to analyse the simulation resutls
<br>

`config_output.R` is used to produce pre-programmed result templates. The templates are located in the `results/quarto_templates`. 

-Quarto templates are not meant to be rendered directly due to their location in the folder, which makes accessing dependencies rather complicated. Instead, to use templates, we use the function `produce_quartos()` that calls upon the parameters found in the `config_output` file.

- To configure the simulation, use the `config_output_MODEL.R` found in the `configuration` folder.

- `config_output_MODEL.R` is meant to be a template, so it is advised to make a copy for your own usage.
 
## `config_output` -  File Structure

Divided in two parts:

#### designation of templates to produce

  
```{r}
#| echo: true
#| code-fold: true
#| code-summary: "Templates to call"
quartos_to_render <-list(
  
  basic_results = FALSE,
  texdoc = FALSE,
  model_info = TRUE,
  sectoral_results = FALSE
  
)

```

#### Templates parameters

For each template available, each parameters from their respective YAML is listed and can be modified as such. Objects from the input configuration can be used by simply stating their name as in the example for `basic_results`.

```{r}
#| echo: true
#| code-fold: true
#| code-summary: "Templates parameters"
#| code-overflow: scroll
#| 


quartos_parameters <- list(
  
  basic_results = list(
    project_name = project_name,
    startyear = 2019,
    shockyear = shockyear,
    endyear = lastyear,
    scenarios = unname(scenario)  # List of scenarii to be plotted
  ),
  
  texdoc = list(
    
    project_name = project_name,
    texdoc_mdls = "default",
    texdoc_exovar = "03.2-exovar.mdl",
    model_files = model_files,
    mdl_folder = model_folder
  ),
  
  model_info = list(
    baseyear =  baseyear,
    lastyear = lastyear,
    classification = classification,
    scenario_baseline = scenario_baseline,
    shocks = scenario,
    calib_files = calib_files,
    model_files = model_files,
    rsolver =  Rsolver,
    project_name = project_name
  ),
  
  
  sectoral_results = list(
    project_name = project_name
  )

  
  
  )
```

## `mdl` Equation files

<br>

  - They contain the equations of the model
  - can be organised in any order
  - first variable that appears on the LHS is the endogenous variable determined by the model
  - simple syntax
  - can be organised in sections
  
```{r}
#| echo: true
#| code-overflow: scroll

##### Endogenous variables' equations

##! Investement
I = Y - CH - G

##! Production (GDP)
Y * p = w*L + p*(delta + r)*K
# Y = ((Phi_L * (L*PROG_L) ^ ((rho-1)/rho )) + (Phi_K * (K*PROG_K) ^ ((rho-1)/rho )))^(rho/(rho-1))
# Mettre alternative possible: Fonction de production directement

##! Households'consumption
 CH = (1 - sigma) * (w*L + p*r*K) / p
# d(log(CH)) = d(log(Y{-1}))

##! Wage (from cost minimization assuming a CES function)
w + L = ((Y / PROG_L) * ((Phi_L) ^ rho) * (w/(p * PROG_L)) ^ (-rho)) + w
# w / (p * PROG_L) = Phi_L * (Y / (L * PROG_L)) ^ (1 / rho)
 

##! Interest rate (from cost minimization assuming a CES function)
r + K = ((Y / PROG_K) * ((Phi_K) ^ rho) * ((delta + r)/PROG_K) ^ (-rho)) + r
# (r + delta)/PROG_K  = Phi_K * (Y / (K * PROG_K)) ^ (1/rho)

##! Capital (from accumulation equation)
d(K) = I{-1} - delta * K{-1}

##! Price 
p = 1


```
  
  

## `mdl` Data calibration files

<br>

- Data calibration files are used to determine the value at the baseyear of endogenous variables, and the default values of exogenous variables.

- Can enter numbers or equations (for the trends)

- The program will check if the calibration is properly balanced


```{r}
#| echo: true
#| code-overflow: scroll

## Long term equilibrium
# Growth rate of labor productivity
GR_PROD_L := 0.01

# Growth rate of population
GR_POP := 0.005

# Growth rate of prices (Inflation)
GR_PRICE := 0.02

# Long-term growth
mu := (1 + GR_PROD_L)*(1 + GR_POP) - 1
GR_nml := (1+mu) * (1 + GR_PRICE) - 1
GR_w_nml := (1 + GR_PROD_L) * (1 + GR_PRICE) - 1


## Parameter of the models

##! Capital depreciation ratio
delta := 0.05

##! Elasticity of substitution between capital and labor (CES function)
rho := 0.1

##! Adjustment parameter of investment to notional capital
alpha_I_Kn := 0.1

## Variables calibrated on real data

##! Interest rate
r := 0.1

##! Price 
p := 1 * (1 + GR_PRICE)^(@year - %baseyear)

# Labor
L :=  1000 * (1 + GR_POP)^(@year - %baseyear)

# Production
Y := 100 * (1 + mu)^(@year - %baseyear)

# Investment
I :=  20 * (1 + mu)^(@year - %baseyear)

# Public spending
G :=  15  * (1 + mu)^(@year - %baseyear)

## Calibration derived from equations
# Consumption
CH := Y - I - G

# Wage
w*L := p*Y - p*(delta + r)*K

# Long-term savings rate
(1 - sigma) := p * CH / (w*L + p*r*K)

# Capital Stock
K := I / (delta + mu)

K_n := K

##! Labor technical progress (CES function)
PROG_L := Y / L 

##! Capital technical progress (CES function)
PROG_K := Y / K

# Labour share in production function
Phi_L := w * L / (p * Y)

# Capital share in production function
Phi_K := p * (r + delta) * K / (p * Y)





```




## Calibration error

<br>

Change the calibration for public expenditure and have a look at the calibration error.

-   Change in the calibration file "01.1-calib.mdl" the value of G. Put **G := 26** instead of **G : = 15**\
-   Save the calibration file.
-   Run the `main`

**What do you notice?**



## Complete Exercise 2 (part 2)

-   Look into the data_full database (you can do this in the `Main_one_eq.R` file)

    -   Create a variable rel_diff that computes the relative difference.
    -   Compute a data.frame that contains the GDP (`Y`) growth rate for the baseline and the shock scenario.
    -   Export as a `.csv` files this database

-   Locate where the `.rds` file containing all the simulations results from this project (project name `one_eq`) can be found

-   Create a quarto `qmd` file that :

    -   loads the results from those simulations (project name `one_eq`)
    -   computes the growth rate for the baseline and shock scenarios
    -   makes a graph comparing those two series

-   In the `config_input_one_eq.R`, change the equation `.mdl` file to use `01.2-eq_basic_mod.mdl` file.

    -   Re-run the simulations and the outputs created.
    -   What has changed?



# Practical Session 2


## Complete Exercise 3

-   Locate the Walras model equation et calibration files

-   Make a copy of the `Main.R`, `config_input_MODEL.R` and `config_output_MODEL.R` files, with a relevant suffix (ie `Main_s.R`)

-   Edit your newly created config_input file:

    -   Change the `project_name` argument to something more relevant
    -   Call the correct `mdl` files
    -   Call upon the correct configuration files in your new main file
    -   Keep the same shock scenario for now

-   Run the simulations with the basic result template.

- Repeat the procedure, this time using the basic Keynes model files. Compare the outputs from the `basic_results` template.

# Results visualisation functions

## `config_output`: How to use templates

## Results analysis: `simpleplot` function

-   `simpleplot` creates graphs based on a vector of variables of a database. By default, the function plots one serie. To see the function syntax in the Rstudio console:

```{r View simpleplot, echo=TRUE, eval=FALSE}
View(ermeeth::simpleplot)
```

-   There are **4 options** to plot a variable using `simpleplot` To select an option, we change the argument "transformation" in the `simpleplot` function:

    Option 1: plot the variable in **level** (transformation = "level" )\
    Option 2: plot the variable in **relative difference** (transformation = "reldiff" )\
    Option 3: plot the variable in **difference** (transformation = "diff" )\
    Option 4: plot the variable in **growth rate** (transformation = "gr" )

## `simpleplot`: plot the variable "Y" in [level]{style="color:red;"} (Option 1)

-   To plot the variable "Y" in level to the baseline scenario, set `transformation = "level"` as shown in the following code:

```{r simpleplot level Y, echo=TRUE, fig.height=6, fig.width=14}
simpleplot(data = data_full,  transformation = "level", series = "Y", label_series = "GDP", startyear = 2020, endyear = 2035, 
           titleplot = "Gross Domestic Product (level)", unit = 1, decimal = 0.1, custom_x_breaks = 1, percent_label = TRUE)

```

-   **Dashed** line : **Baseline** simulation
-   **Solid** line : **Shock** simulation
-   `label_series = "GDP"` Changes the name of the variable "Y" into "GDP"

## `simpleplot`: plot the variable "Y" in [relative]{style="color:red;"} difference (Option 2)

-   The **relative** difference in the shock compared to the baseline for variable Y is calculated using the following formula: \begin{equation}
    reldiff_{t} = (Y_{shock_{t}}-Y_{baseline_{t}})/Y_{baseline_{t}} = Y_{shock_{t}}/Y_{baseline_{t}}-1
    \end{equation}

-   To plot the variable "Y" in relative difference to the baseline scenario, set `transformation = "reldiff"` as shown in the following code:

```{r simpleplot reldiff, echo=TRUE, fig.height=6, fig.width=14}
simpleplot(data = data_full,  transformation = "reldiff", series = "Y", label_series = "GDP", startyear = 2020, endyear = 2035, 
           titleplot = "Gross Domestic Product (percentage change)", unit = "percent", decimal = 0.1, custom_x_breaks = 2)

```

-   **Only one plot here !** This is the (relative) difference between the shock and the baseline

## `simpleplot`: plot the variable "Y" in [absolute]{style="color:red;"} difference (Option 3)

-   The **absolute** difference in the shock compared to the baseline for variable Y is calculated using the following formula:

-   The variation of Y is calculated using the following formula: \begin{equation}
    diff_{t} = Y_{shock_t} - Y_{baseline_{t}}
    \end{equation}

-   To plot the variable "Y" in absolute difference to the baseline scenario, set `transformation = "diff"` as shown in the following code

```{r simpleplot diff GDP, echo=TRUE, fig.height=6, fig.width=14}
simpleplot(data = data_full,  transformation = "diff", series = "Y", label_series = "GDP", startyear = 2020, endyear = 2035, 
           titleplot = "Gross Domestic Product (absolute change)", unit = 1, decimal = 0.1)

```

## *`simpleplot`*: plot the variable "Y" in [growth rate]{style="color:red;"} (Option 4) {.scrollable}

-   The growth rate (over time) of Y is calculated using the following formula: \begin{equation}
    gr_{shock_{t}} = (Y_{shock_{t}}-Y_{shock_{t-1}})/Y_{shock_{t-1}}
    \end{equation} \begin{equation}
    gr_{baseline_{t}} = (Y_{baseline_{t}}-Y_{baseline_{t-1}})/Y_{baseline_{t-1}}
    \end{equation}

-   By growth rate, we mean annual percentage change


-   The growth rate (over time) of Y is calculated using the following formula: \begin{equation}
    gr_{shock_{t}} = (Y_{shock_{t}}-Y_{shock_{t-1}})/Y_{shock_{t-1}}
    \end{equation} \begin{equation}
    gr_{baseline_{t}} = (Y_{baseline_{t}}-Y_{baseline_{t-1}})/Y_{baseline_{t-1}}
    \end{equation}


-   To plot the variable "Y" in growth rate to the baseline scenario, set `transformation = "gr"` as shown in the following code:

```{r simpleplot gr, echo=TRUE, fig.height=6, fig.width=14}
simpleplot(data = data_full,  transformation = "gr", series = "Y", label_series = "GDP", startyear = 2020, endyear = 2035, 
           titleplot = "Gross Domestic Product (yearly percentage change)", unit = "percent", decimal = 0.01)

```

## Plot a graph with the contribution of "CH", "I" and "G" on "GDP"

-   The contribution of each variable to the relative change Y in the shock compared the baseline is calculated using the following formula: \begin{equation}
    \frac{Y_{shock}}{Y_{baseline}}-1= (\frac{CH_{shock}}{CH_{baseline}}-1)*(\frac{CH_{baseline}}{Y_{baseline}}) +
    (\frac{I_{shock}}{I_{baseline}}-1)*(\frac{I_{baseline}}{Y_{baseline}}) +  (\frac{G_{shock}}{G_{baseline}}-1)*(\frac{G_{baseline}}{Y_{baseline}})
    \end{equation}

-   The relative change of Y is the weighed average of the relative change of its components

```{r Graph GDP and contrib, echo=TRUE, fig.height=6, fig.width=14}
contrib_comp <- c( "CH", "I", "G")
contrib_comp_label <- c("Households consumption", "Investment", "Public spending")

data_plot <-  contrib_longformat(data_full,"Y", contrib_comp, scenar = c("baseline",scenario_name))

A <- contrib.plot(data_plot, series = contrib_comp,label_series = contrib_comp_label,
             startyear = 2020, titleplot = "Contributions to change in GDP", line_tot = TRUE)

B <- simpleplot(data_full,c("CH", "I", "G"), contrib_comp_label, startyear, endyear, titleplot = "Components of the GDP (in difference from baseline)")

ggarrange(A,B,
          labels = c("(a)", "(b)"),
          hjust = -0.5, vjust = 1.5,
          ncol = 2, nrow = 1,
          widths = 2,  heights = 1)

```

------------------------------------------------------------------------

```{r}

ggarrange(A,B,
          labels = c("(a)", "(b)"),
          hjust = -0.5, vjust = 1.5,
          ncol = 2, nrow = 1,
          widths = 2,  heights = 1)

```

## Summary tables

<br>

With the `dplyr` package, it can be easy to modify `data_full` in order to synthetize results.

<br>
We provide two functions `table_macro()` and `table_reference()` that yield automated raw tables (`tibbles`) that can later on be formatted with packages such as `gt` or `flextable`.

  - `table_reference()`  produces results for a given scenario independently (growth rates, levels...)
  - `table_macro()`  produces results for a given scenario in relative to the `baseline` scenario
  

See `basic_results` template for examples of usage.

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "table_macro arguments"


table_macro <- function(data,
                        shock = "ct1",
                        relative_variation = NULL,
                        level_diff = NULL,
                        percent_diff = NULL,
                        order = NULL,
                        time_vector = if(exists("time_waypoints")){time_waypoints}else{c(1,2,3,5,10,30,60)},
                        end_year = 2050,
                        shock_year = 2021,
                        digits_numb = 2
)

```

## TeXdoc

- TeXdoc is function that reads `mdl` files to translate the equations into LaTeX code in order to retranscribe them in documents is a more legible manner.

  + Not perfect yet!
  + Quite sensitive to how `mdl` files are written, especially when it come to sectionning text
  
- We added a functionnality that transforms the `tex` output into a `qmd` output that can be called upon in qmd


  
```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "TeXdoc syntax"


teXdoc(     sources   = c("02.1-eq.mdl"),
            exo       = c("02.1-exovar.mdl"),
            base.path = file.path("src","model","training"),
            out       = "model-eq",
            out.path  = "results_side_files")


make_eq_qmd(preface = file.path("results_side_files",  "model-eq_preface.tex"),
            maintex = file.path("results_side_files", "model-eq.tex"),
            out.dir = "results_side_files" )


```

The output generated are $\LaTeX$ files as well as `.qmd` that may be included in other reports, found in the `results\quarto_render` folder:
  
    - equation file
    - exogenous file
    - glossary file

To facilitate the usage, quarto template is available that can be called from `config_output`


## Live Demo {.center}

**TeXdoc files**

**TeXdoc quarto template**



## Complete Exercise 4 {.scrollable}

-   Create your quarto file and create graphs using shortcut plotting functions

    -   `simple_plot()`
    -   `contrib_plot()`

-   Enable the use of the Texdoc template and model_info templates in the `config_output` to generate the equations list for your model.

-   Include the equation index generated by TeXdoc in your newly created `.qmd`

-   Create a table that summarizes the results in relative difference from the baseline for one year after the initial shock, then 2, 3, 10 and 50 for the following variables : GDP, household consumption, public spending and investment. Here's a few steps to help you achieve this:

-   *Identify the year of the shock*

-   *identify the year that correspond to $t+2$, $t+3$, $t+10$ and $t+50$ where $t$ is the year of the initial shock.*

-   *Create a new data.frame from data_full that contains only the relevant variables, compute the relative difference, and keep only the information desired*

-   *reorginize your data.frame to format nicely*

- Use your new `.qmd` to compare simulation results of a shock on public expenditure in a basic Walras model vs a basic Keynesian model by generating two different simulation outputs.

# Workshop day one completed !


# Practical Session 3

## Complete Exercise 5

Exercise 5 : Loading the neokeynesian model

-   Locate the Neokeynesian model `.mdl` files

-   Do the necessary steps (create and modify the relevant files) run the same shock on public spending as we did for the Walras model.

    -   hint: don't forget to change the `project_name` argument

-   Create a similar `.qmd` file as we did for the Walras model. (hint: this can be done very quickly ;) ), complete with the equations lists from TeXdoc.

-   Let's complicate a little bit: on the qmd, place next to eachother the macroeconomic components graphs for each model simulation and same for the table.

## Making 2_calib_shock files


  -   Shock Calibration are found in the folder **configuration/scenarii_calib**. 
  -   Inside you would find two main types of R scripts:
    
    + the ones that are used to calibrate baselines (start with **1_calib_**)
    + the ones used to calibrate shocks.(start with **2_calib_shock**) 
    
  - After these common name basis, you would find the baseline name or the shock code called in `config_input`.
  
  
Shocks are defined in two main different ways:

  + Loading and xlsx or csv file containing the evolution of the variable that we want to shock over the time
  + Coding the shock in R in the same file
  
## Structure of a `2_calib_shock_` file (1)

### A two step process

  - Loading `calib_new_base`
    
    +  `calib_new_base` : a calibration data_frame built on the calibration `mdl` files that incorporate potential changes to the baseline
    + cannot be seen in the environment, have to rely on the *calibration bubble* tool
    
  - Creating a  `shock_ch` data.frame that contains the modified version of the exogenous variables used for the shock
      + must be called `shock_ch`
      + must include the `year` column at the end
      + last operation of the script mst be defining `shock_ch`
      
    - How you achieve this modified series is up to you (R code, loading csv, fetching data online etc)

## Structure of a `2_calib_shock_` file (2)

```{r}
#| echo: true
#| eval: false

# Load the selected series for the range baseyear:lastyear
selection <- calib_new_base %>% select(year, y,g)

## Change in exogenous variables
#(1) Using formulas
shock_ch <- mutate(selection,
                   g = ifelse(year >= 2021, g + 0.01*y, g)

                   )  %>% select(-y)


```

## Possibly changing the baseline calibration 1_calib_baseline

The baseline calibration file is changed in a similar way :

- Loading `OGcalib`
    
    +  `OGcalib` : the calibration data_frame built on the calibration `mdl` files direclty
    + cannot be seen in the environment, have to rely on the *calibration bubble* tool (option baseline_calibration `TRUE`)
    
  - Creating a  `baseline_ch` data.frame that contains the modified version of the exogenous variables used for the shock
      + must be called `baseline_ch`
      + must include the `year` column at the end
      + last operation of the script mst be defining `baseline_ch`
      
    - How you achieve this modified series is up to you (R code, loading csv, fetching data online etc)


## Exercise 6 part 1

-   Locate the shock calibration file we have been using so far.

-   Make a copy and call it `2_calib_shock_g_bis.R`

-   Make the necessary changes to the `config_input` file to be able to run this new shock.

-   See if you can reuse the `.qmd` file from @sec-3_1

-   Test the following changes on you new shock calibration file :
      
      - increase in public spending of 5% of GDP
    
- Change your config_input file to simulate both the original shock in public spending and this new one and view both results at once 

## Exercise 6 part 2

- Create new shocks from scratch :
  
    - A sudden (but temporary) decrease in population of -1% in the year 2022
    - A yearly population decrease starting the year 2030 of -0.1% 
    
- Create a new shock calibration file aimed at testing labour productivity shocks (empty for now)

- What is the baseline labour productivity growth in this model ?

- What variable do we have change to create a shock scenario on labour productivity growth and why can't it be `GR_PROG_L`?
  
- Do the necessary (model, results visualization) to answer this question: 
  - **What happens if labour productivity growth increases temporarily to 10% in 2023?**
  
  
# Practical Session 4

## equations over lists

So far we have seen mainly what happens in macro models, assuming the economy is one unique sector. 

Equations can become multisectoral using the following syntax :

```{r}
#| echo: true
#| eval: false

## BEFORE
CH = 50 ## means all CH is 50

## AFTER
CH[c] = 50 ## means CH for each commodity c will be 50
```

When using list variables, an aggregated variable should be added :

```{r}
#| echo: true
#| eval: false

## BEFORE
CH = sum(CH[c] on c)

```

## lists 

Lists of sectors/commodities/ are defined in the `model` folder in the `lists.mdl` file

```{r}
#| echo: true
#| eval: false

# Sectors and commodities
%list_sec := s001 s002
%list_com := c001 c002

# Default iterators
s in %list_sec
c in %list_com


```

## Classification

*Optional*

When using multiple sectors, the `classification` parameter tells the model where to find the sector and commodities names, if the suffixes used start with `c` or `s` 

## Do Exercise 7 part 1
- Using the `01.1_eq_one_eq.mdl` model, add an equation to allow for 2 types of goods to be consumed.
- Check that the simulations run for a `c2_s2` classification, and then a `c4_s4` classification.
- What do you notice in terms of model size?

### Part 2



## Do Exercise 7 part 2

- Locate the mutlisectoral `.mdl` files. 
- Do the necessary to run simulation on a increase in public expenditure scenario in this scenario


